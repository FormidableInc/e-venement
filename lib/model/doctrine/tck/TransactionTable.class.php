<?php
/**********************************************************************************
*
*	    This file is part of e-venement.
*
*    e-venement is free software; you can redistribute it and/or modify
*    it under the terms of the GNU General Public License as published by
*    the Free Software Foundation; either version 2 of the License.
*
*    e-venement is distributed in the hope that it will be useful,
*    but WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*    GNU General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with e-venement; if not, write to the Free Software
*    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*
*    Copyright (c) 2006-2015 Baptiste SIMON <baptiste.simon AT e-glop.net>
*    Copyright (c) 2006-2015 Libre Informatique [http://www.libre-informatique.fr/]
*
***********************************************************************************/
?>
<?php

/**
 * TransactionTable
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 */
class TransactionTable extends PluginTransactionTable
{
    /**
     * Returns an instance of this class.
     *
     * @return object TransactionTable
     */
    public static function getInstance()
    {
        return Doctrine_Core::getTable('Transaction');
    }
  
  protected function prepareQuery($q, $params)
  {
    $logger = sfContext::getInstance()->getLogger();

    $logger->warning("\n" . $q . "\n\n--" . implode(', ', $params));

    $pdo = Doctrine_Manager::getInstance()->getCurrentConnection()->getDbh();
    
    $st = $pdo->prepare($q);    
    $st->execute($params);

    return $st;
  }

  protected function getSingleResult($q, $params)
  {
    return $this->prepareQuery($q, $params)->fetchColumn();
  }

  protected function getResult($q, $params)
  {
    return $this->prepareQuery($q, $params)->fetchAll(Doctrine_Core::FETCH_ASSOC);
  }
  
  // $tickets can be NULL (all), 'asked' for asked tickets or an other not-empty-string for printed/integrated/cancelling tickets
  public function createQuery($alias = 't', $tickets = NULL, $with_products = false)
  {
    $tck = 'tck' != $alias ? 'tck' : 'tck2';
    $m   = 'm'   != $alias ? 'm'   : 'm2';
    
    // this is for $tickets == 'asked', for $tickets == something_else it becomes "NOT ($str)"
    $str = "$tck.printed_at IS NULL AND $tck.integrated_at IS NULL AND $tck.cancelling IS NULL";
    
    $q = parent::createQuery($alias);
    $a = $q->getRootAlias();
    $q->leftJoin("$a.Tickets $tck".(is_null($tickets) ? '' : ' WITH '.($tickets == 'asked' ? $str : "NOT ($str)")))
      ->leftJoin("$tck.Duplicatas duplicatas")
      ->leftJoin("$tck.Cancelled cancelled")
      ->leftJoin("$tck.Manifestation $m");
    if ( $with_products )
      $q->leftJoin("$a.BoughtProducts bp".(is_null($tickets) ? '' : ' WITH '.($tickets == 'asked' ? 'bp.integrated_at IS NULL' : 'bp.integrated_at IS NOT NULL')));
      
    if ( ($dom = sfConfig::get('project_internals_users_domain', false)) && $dom != '.' )
      $q->leftJoin("$a.User tu ON tu.id = (SELECT tv.sf_guard_user_id FROM TransactionVersion tv WHERE tv.id = $a.id AND tv.version = 1)")
        ->leftJoin('tu.Domain d')
        ->andWhere('d.name ILIKE ? OR d.name = ?', array('%.'.$dom, $dom));
    
    return $q;
  }
  public function createQueryForManifestations($alias = 't', $tickets = NULL, $with_products = false)
  {
    return $this->createQuery($alias, $tickets, $with_products)
      ->andWhere('e.museum = ?', false);
  }
  public function createQueryForMuseum($alias = 't', $tickets = NULL, $with_products = false)
  {
    return $this->createQuery($alias, $tickets, $with_products)
      ->andWhere('e.museum = ?', true);
  }
  public function createQueryForStore($alias = 't', $culture = NULL)
  {
    $q = Doctrine_Query::create()->from('Transaction '.$alias)
      ->leftJoin("$alias.BoughtProducts bp")
      ->leftJoin('bp.Declination d')
      ->leftJoin('d.Translation dt WITH dt.lang '.($culture ? '=' : '!=').' ?', $culture)
      ->leftJoin('d.Product pdt')
      ->leftJoin('pdt.Translation pdtt WITH pdtt.lang '.($culture ? '=' : '!=').' ?', $culture)
      ->leftJoin('pdt.Category c')
      ->leftJoin('c.Translation ct WITH ct.lang '.($culture ? '=' : '!=').' ?', $culture)
      ->leftJoin('bp.Price price')
      ->leftJoin('pdt.Prices pdtp WITH pdtp.id = price.id')
    ;
    return $q;
  }
  
  public function createQueryForLineal($a = 't')
  {
    $q = parent::createQuery($a);
    $q->leftJoin("$a.Tickets tck ON tck.transaction_id = t.id AND tck.duplicating IS NULL AND (tck.printed_at IS NOT NULL OR tck.cancelling IS NOT NULL OR tck.integrated_at IS NOT NULL)")
      ->leftJoin("$a.Invoice i")
      ->leftJoin('tck.Manifestation m')
      ->leftJoin('m.Event e')
      ->orderBy("$a.updated_at, $a.id, tck.updated_at");
    return $q;
  }
  
  public function fetchOneById($id)
  {
    $q = $this->createQuery()
      ->andWhere('id = ?',$id);
    return $q->fetchOne();
  }
  public function findOneById($id)
  {
    return $this->fetchOneById($id);
  }
  
  public function addCreated_byFilter($filters, &$params)
  {
    $created_by = '';

    if ( array_key_exists('created_by', $filters) && $filters['created_by'] )
    {
      $created_by = " AND tv.sf_guard_user_id = ?";
      $params[] = $filters['created_by'];
    }

    return $created_by;
  }

  public function addCreated_atFilter($filters, &$params)
  {
    $created_at = '';

    if ( array_key_exists('date', $filters) )
    {
      $dates = $filters['date'];

      if ( array_key_exists('from', $dates) && $dates['from'] )
      {
        $created_at .= " AND t.created_at >= ?";
        $params[] = $dates['from'];
      }

      if ( array_key_exists('to', $dates) && $dates['to'] )
      {
        $created_at .= " AND t.created_at < ?";
        $params[] = $dates['to'];
      }
    }

    return $created_at;
  }

  public function addDomainFilter($filters = [], &$params)
  {
    $domain = '';
    $dom = sfConfig::get('project_internals_users_domain', false);

    if ( $dom )
    {
      $domain = " AND d.name = ?";
      $params[] = $dom;
    }

    return $domain;
  }

  public function addClosedFilter($filters = [], &$params)
  {
    $closed = ' AND (t.closed = false';

    if ( array_key_exists('all', $filters) && $filters['all'] )
    {
      $closed .= ' OR t.closed = true';
    }

    return $closed . ')';
  }

  public function getDebtsQuery($filters = [], &$params)
  {
    $filters_query = '';
    $filters_query .= $this->addClosedFilter($filters, $params);
    $filters_query .= $this->addCreated_byFilter($filters, $params);
    $filters_query .= $this->addCreated_atFilter($filters, $params);
    $filters_query .= $this->addDomainFilter($filters, $params);
    
    $q = "SELECT domain, tid, last_user, created_at, updated_at, invoice, contact, organism, outcomes, incomes, outcomes - incomes AS day_debt
      FROM (
        SELECT 
          periods.domain, tid, last_user, created_at, updated_at, invoice, contact, organism,
          coalesce(ticket_value, 0) + coalesce(product_value, 0) AS outcomes, 
          coalesce(payment, 0) AS incomes
        FROM (
        
          SELECT d.name AS domain, t.id AS tid, 
            u.username||' ('||u.first_name||' '||u.last_name||')' AS last_user, 
            i.id AS invoice, 
            c.name||' '||c.firstname AS contact, 
            o.name||' ('||o.city||')' AS organism, 
            t.created_at,
            t.updated_at
          FROM transaction t
          INNER JOIN transaction_version tv ON tv.id = t.id AND tv.version = 1
          INNER JOIN domain d ON d.sf_guard_user_id = t.sf_guard_user_id
          INNER JOIN sf_guard_user u ON u.id = t.sf_guard_user_id
          LEFT JOIN contact c ON c.id = t.contact_id
          LEFT JOIN professional p ON p.id = t.professional_id
          LEFT JOIN organism o ON o.id = p.organism_id
          LEFT JOIN invoice i ON i.transaction_id = t.id
          WHERE t.transaction_id IS NULL
          $filters_query
              
        ) AS periods
        LEFT JOIN (
          SELECT domain, transaction_id, sum(value) AS payment
          FROM (
            SELECT d.name AS domain, p.transaction_id, p.id, coalesce(p.value, 0) AS value
            FROM payment p
            INNER JOIN domain d ON d.sf_guard_user_id = p.sf_guard_user_id
            UNION
            SELECT d.name AS domain, t.transaction_id, p.id, coalesce(p.value, 0) AS value
            FROM payment p
            INNER JOIN domain d ON d.sf_guard_user_id = p.sf_guard_user_id
            INNER JOIN transaction t ON t.id = p.transaction_id
          ) AS p
          GROUP BY domain, transaction_id
        ) AS p ON p.transaction_id = tid AND p.domain = periods.domain
        LEFT JOIN (
          SELECT domain, transaction_id, sum(value + taxes) AS ticket_value
          FROM (
            SELECT d.name AS domain,
              t.transaction_id, 
              coalesce(t.value, 0) + coalesce(tc.value, 0) AS value, 
              coalesce(t.taxes, 0) + coalesce(tc.taxes, 0) AS taxes
            FROM ticket t
            INNER JOIN transaction tr ON tr.id = t.transaction_id
            INNER JOIN domain d ON d.sf_guard_user_id = t.sf_guard_user_id
            LEFT JOIN ticket tc ON tc.cancelling = t.id
            WHERE t.duplicating IS NULL
            AND (t.printed_at IS NOT NULL OR t.integrated_at IS NOT NULL)
          ) AS tickets
          GROUP BY domain, transaction_id
        ) AS t ON t.transaction_id = tid AND t.domain = periods.domain
        LEFT JOIN (
          SELECT d.name AS domain, bp.transaction_id, sum(value) AS product_value
          FROM bought_product bp
          INNER JOIN domain d ON d.sf_guard_user_id = bp.sf_guard_user_id
          WHERE integrated_at IS NOT NULL
          GROUP BY d.name, bp.transaction_id
          ORDER BY bp.transaction_id
        ) AS bp ON bp.transaction_id = tid AND bp.domain = periods.domain
      ) AS debts
      WHERE outcomes - incomes != 0
      ORDER BY updated_at
    ";

    return $q;
  }

  public function findDebts($offset = -1, $limit = -1, $filters = [])
  {
    //throw new Exception(print_r($filters, true));
    
    $params = [];

    $q = $this->getDebtsQuery($filters, $params) . "
      OFFSET $offset
      LIMIT $limit
    ";

    return $this->getResult($q, $params);
  }
  
  public function findDebtsCount($filters = [])
  {
    $params = [];

    $debts = $this->getDebtsQuery($filters, $params);

    $q = "SELECT count(*) FROM ($debts) AS debts;";

    return $this->getSingleResult($q, $params);
  }

  public function retrieveDebtsList()
  {
    $q = Doctrine_Query::create()->from('Transaction t')
      ->leftJoin('t.Contact c')
      ->leftJoin('t.Professional p')
      ->leftJoin('p.ProfessionalType pt')
      ->leftJoin('p.Organism o')
      ->leftJoin('t.Invoice i')
    ;
    
    if ( ($dom = sfConfig::get('project_internals_users_domain', false)) && $dom != '.' )
      $q->leftJoin("t.User u ON u.id = (SELECT tv.sf_guard_user_id FROM TransactionVersion tv WHERE tv.id = t.id AND tv.version = 1)")
        ->leftJoin('u.Domain d')
        ->andWhere('d.name ILIKE ? OR d.name = ?', array('%.'.$dom, $dom));
    
    if ( !sfContext::getInstance()->getUser()->hasCredential('tck-ledger-all-users') )
      $q->leftJoin('t.Version ctv WITH ctv.version = 1')
        ->andWhere('ctv.sf_guard_user_id = ?',sfContext::getInstance()->getUser()->getId());
    
    $this->setDebtsListCondition($q);
    return $q;
  }
  public static function setDebtsListCondition(Doctrine_Query $q, $dates = array('from' => NULL, 'to' => NULL), $alias = array('tck2', 'pdt2'))
  {
    self::addDebtsListBaseSelect($q)
      ->addSelect(str_replace(array('%%tck%%', '%%pdt%%'), array('tck', 'pdt'), $outcomes = '((SELECT (CASE WHEN COUNT(%%tck%%.id) = 0 THEN 0 ELSE SUM(%%tck%%.value + CASE WHEN %%tck%%.taxes IS NULL THEN 0 ELSE %%tck%%.taxes END) END) FROM Ticket %%tck%% WHERE '.self::getDebtsListTicketsCondition('%%tck%%', $dates['to'], $dates['from']).') + (SELECT (CASE WHEN COUNT(%%pdt%%.id) = 0 THEN 0 ELSE SUM(%%pdt%%.value) END) FROM BoughtProduct %%pdt%% WHERE '.self::getDebtsListProductsCondition('%%pdt%%', $dates['to'], $dates['from']).'))').' AS outcomes')
      ->addSelect(str_replace('%%pp%%' , 'pp' , $incomes  = '(SELECT (CASE WHEN COUNT(%%pp%%.id)  = 0 THEN 0 ELSE SUM(%%pp%%.value) END) FROM Payment %%pp%% WHERE %%pp%%.transaction_id = t.id '.($dates['from'] ? " AND %%pp%%.created_at >= '".$dates['from']."'" : '').($dates['to'] ? " AND %%pp%%.created_at < '".$dates['to']."'" : '').')').' AS incomes')
      ->andWhere(str_replace(array('%%tck%%', '%%pdt%%'), $alias, $outcomes).' - '.str_replace('%%pp%%', 'p2', $incomes).' != 0');
    return $q;
  }
  public static function getDebtsListTicketsCondition($table = 'tck', $date = NULL, $from = NULL)
  {
    $r = "$table.transaction_id = t.id AND $table.duplicating IS NULL AND ($table.printed_at IS NOT NULL OR $table.integrated_at IS NOT NULL OR $table.cancelling IS NOT NULL)";
    if ( !is_null($date) )
      $r .= " AND ($table.cancelling IS NULL AND ($table.printed_at IS NOT NULL AND $table.printed_at < '$date' OR $table.integrated_at IS NOT NULL AND $table.integrated_at < '$date') OR $table.cancelling IS NOT NULL AND $table.created_at < '$date')";
    if ( !is_null($from) )
      $r .= " AND ($table.cancelling IS NULL AND ($table.printed_at IS NOT NULL AND $table.printed_at >= '$from' OR $table.integrated_at IS NOT NULL AND $table.integrated_at >= '$from') OR $table.cancelling IS NOT NULL AND $table.created_at >= '$from')";
    return $r;
  }
  public static function getDebtsListProductsCondition($table = 'pdt', $date = NULL, $from = NULL)
  {
    $r  = '';
    $r .= $table.'.transaction_id = t.id AND '.$table.'.integrated_at IS NOT NULL';
    if ( !is_null($date) )
      $r .= " AND $table.integrated_at < '$date'";
    if ( !is_null($from) )
      $r .= " AND $table.integrated_at >= '$from'";
    return $r;
  }
  public static function addDebtsListBaseSelect(Doctrine_Query $q)
  {
    return $q
      ->select($fields = 't.id, t.closed, t.updated_at, c.id, c.name, c.firstname, p.id, p.name, pt.id, pt.name, o.id, o.name, o.city, i.id')
      ->addSelect("'yummy' AS yummy") // a trick to avoid an obvious bug which removes the name of the field following directly the first ones (??)
    ;
  }
}
